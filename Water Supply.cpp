
Water Supply
The country of Chefland has 
N
N cities, with its capital being at city 
1
1.
Unfortunately, the only source of water in the entire country is the capital, and so water must be sent via pipes to all the other cities.
For each city 
i
>
1
i>1, there is a unique city 
p
i
<
i
p 
i
​
 <i such that there is a pipe connecting cities 
i
i and 
p
i
p 
i
​
 . Note that this ensures every city is connected to city 
1
1 via a unique sequence of pipes.

Over time, the pipes have degraded and all now leak water.
The pipe connecting cities 
i
i and 
p
i
p 
i
​
  has a leakiness of 
A
i
A 
i
​
 , which means that every 
A
i
A 
i
​
 -th unit of water passing through it is lost entirely.
For example, with a leakiness of 
4
4, if 
13
13 units of water enter the pipe, only 
10
10 will leave it (the 
4
4-th, 
8
8-th, 
12
12-th unit will be lost).

On each day 
i
i (
1
≤
i
≤
N
1≤i≤N), the capital (city 
1
1) generates 
K
K units of water, which are then all sent to city 
i
i via the pipes (other cities lying on the path between 
1
1 and 
i
i don't get to keep any of this water).
Due to the leakiness of the pipes, some of these 
K
K units of water will be lost as the water passes sequentially through the pipes.
Let 
R
i
R 
i
​
  denote the amount of water received by city 
i
i.

Each day is completely independent - that is, all the pipes reset at the start of each day, and behave as if no water has passed through them before.
See the sample cases below for more clarity.

You would like to maximize 
min
⁡
(
R
1
,
R
2
,
…
,
R
N
)
min(R 
1
​
 ,R 
2
​
 ,…,R 
N
​
 ), i.e. maximize the minimum amount of water received by any city.
To achieve this, at most once, you can choose an index 
i
i (
2
≤
i
≤
N
2≤i≤N), and set 
A
i
:
=
K
+
1
A 
i
​
 :=K+1.
Functionally, this ensures that no water leaks through this pipe.

Find the maximum possible value of 
min
⁡
(
R
1
,
R
2
,
…
,
R
N
)
min(R 
1
​
 ,R 
2
​
 ,…,R 
N
​
 ) after fixing at most one pipe.

Input Format
The first line of input will contain a single integer 
T
T, denoting the number of test cases.
Each test case consists of three lines of input.
The first line of each test case contains two space-separated integers 
N
N and 
K
K — the number of cities and the daily water generated by city 
1
1.
The second line contains 
N
−
1
N−1 space-separated integers 
p
2
,
p
3
,
…
,
p
N
p 
2
​
 ,p 
3
​
 ,…,p 
N
​
  — the parents of the non-capital cities.
The third line contains 
N
−
1
N−1 space-separated integers 
A
2
,
A
3
,
…
,
A
N
A 
2
​
 ,A 
3
​
 ,…,A 
N
​
  — the leakiness values of the pipes.
Output Format
For each test case, output on a new line the maximum possible value of 
min
⁡
(
R
1
,
R
2
,
…
,
R
N
)
min(R 
1
​
 ,R 
2
​
 ,…,R 
N
​
 ) after fixing at most one pipe.

Constraints
1
≤
T
≤
10
5
1≤T≤10 
5
 
2
≤
N
≤
2
⋅
10
5
2≤N≤2⋅10 
5
 
1
≤
p
i
<
i
1≤p 
i
​
 <i
1
≤
K
≤
10
9
1≤K≤10 
9
 
1
≤
A
i
≤
10
9
1≤A 
i
​
 ≤10 
9
 
The sum of 
N
N over all test cases won't exceed 
2
⋅
10
5
2⋅10 
5
 .
Sample 1:
Input
Output
5
2 43
1
8
3 29
1 1
4 7
5 197
1 2 1 3
15 20 17 1
5 197
1 2 1 3
15 1 17 1
10 387
1 1 3 2 3 6 4 2 5
89 6 20 76 34 43 12 5 12
43
25
175
0
307
Explanation:
Test case 
1
1: There are two cities, with 
1
1 connected to 
2
2 with a pipe of leakiness 
8
8.
We can just fix this pipe, and there are no leaky pipes - so cities 
1
1 and 
2
2 will both receive 
K
=
43
K=43 units of water, which is the best we can do.

Test case 
2
2: There are three cities, with cities 
2
2 and 
3
3 both directly connected to city 
1
1 via pipes of leakiness 
4
4 and 
7
7 respectively.
We have two choices:

Fix the pipe between 
1
1 and 
2
2.
City 
1
1 will receive all 
K
=
29
K=29 units of water.
City 
2
2 will also receive all 
K
=
29
K=29 units of water, since the pipe connecting it to 
1
1 is fixed.
City 
3
3 will receive 
25
25 units of water - 
29
29 units will flow from 
1
1 to 
3
3 via a pipe of leakiness 
7
7, so every seventh unit will be lost - meaning units 
7
,
14
,
21
,
28
7,14,21,28 will be lost, for a total of four.
Fix the pipe between cities 
1
1 and 
3
3.
Cities 
1
1 and 
3
3 will now receive 
K
=
29
K=29 units of water.
City 
2
2 will receive 
29
−
7
=
22
29−7=22 units of water, since 
7
7 units will be lost when 
29
29 pass through a pipe will leakiness 
4
4.
The first option has the minimum water received at 
25
25, while the second option has it at 
22
22; so the first option is better and the answer is 
25
25.

Test case 
3
3: The optimal solution is to choose 
i
=
5
i=5 and fix the pipe between 
5
5 and 
p
5
=
3
p 
5
​
 =3. with 
K
=
197
K=197, this results in the following:

Day 
1
1: 
197
197 units of water are sent to city 
1
1. No pipes are needed, no water is lost, so 
R
1
=
197
R 
1
​
 =197.
Day 
2
2: 
197
197 units of water are sent to city 
2
2, along the path 
1
→
2
1→2. The only pipe along the way is 
A
2
=
15
A 
2
​
 =15, and 
13
13 units of water will be lost. So, 
R
2
=
197
−
13
=
184
R 
2
​
 =197−13=184.
Day 
3
3: 
197
197 units of water are sent to city 
3
3, along the path 
1
→
2
→
3
1→2→3.
The first pipe is 
A
2
=
15
A 
2
​
 =15, so just as before, 
13
13 units of water will be lost, and 
184
184 units will reach city 
2
2.
The second pipe is 
A
3
=
20
A 
3
​
 =20, and with 
184
184 units passing through it, 
9
9 units will be lost.
This results in 
R
3
=
184
−
9
=
175
R 
3
​
 =184−9=175.
Day 
4
4: 
197
197 units of water are sent to city 
4
4, along the path 
1
→
4
1→4.
The only pipe is 
A
4
=
17
A 
4
​
 =17, which results in 
R
4
=
186
R 
4
​
 =186.
Day 
5
5: 
197
197 units of water are sent to city 
5
5, along the path 
1
→
2
→
3
→
5
1→2→3→5.
As seen earlier, 
175
175 units will reach city 
3
3, and then because we fixed the pipe between 
3
3 and 
5
5, all of these will reach city 
5
5, for 
R
5
=
175
R 
5
​
 =175.
This obtains 
min
⁡
(
R
1
,
R
2
,
R
3
,
R
4
,
R
5
)
=
175
min(R 
1
​
 ,R 
2
​
 ,R 
3
​
 ,R 
4
​
 ,R 
5
​
 )=175, which is optimal here.

Test case 
4
4: No matter which pipe is fixed, some city will receive 
0
0 units of water.
#include <bits/stdc++.h>
using namespace std;

struct Edge {
    int to;
    long long A;
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;
    while (T--) {
        int N;
        long long K;
        cin >> N >> K;

        vector<int> parent(N + 1);
        for (int i = 2; i <= N; i++) cin >> parent[i];

        vector<long long> A(N + 1);
        for (int i = 2; i <= N; i++) cin >> A[i];

        vector<vector<Edge>> g(N + 1);
        for (int i = 2; i <= N; i++) {
            g[parent[i]].push_back({i, A[i]});
        }

        // Compute water received without any fix
        vector<long long> R(N + 1);
        function<void(int, long long)> dfs = [&](int u, long long water) {
            R[u] = water;
            for (auto &e : g[u]) {
                long long pass = water - water / e.A;
                dfs(e.to, pass);
            }
        };
        dfs(1, K);

        long long minR = *min_element(R.begin() + 1, R.end());

        // Binary search for maximum possible minR
        long long lo = minR, hi = K, ans = minR;

        auto can = [&](long long M) -> bool {
            // check if at most one fix can achieve >= M everywhere
            int fixes = 0;
            function<long long(int, long long)> dfs2 = [&](int u, long long water) -> long long {
                if (water < M) return -1; // impossible path
                for (auto &e : g[u]) {
                    long long pass = water - water / e.A;
                    if (pass < M) {
                        if (fixes == 1) return -1; // already used fix
                        fixes++;
                        // fixing this edge
                        if (dfs2(e.to, water) == -1) return -1;
                    } else {
                        if (dfs2(e.to, pass) == -1) return -1;
                    }
                }
                return 0LL;
            };
            return dfs2(1, K) != -1;
        };

        while (lo <= hi) {
            long long mid = (lo + hi) / 2;
            if (can(mid)) {
                ans = mid;
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }

        cout << ans << "\n";
    }
    return 0;
}
